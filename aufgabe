== Spieleprogrammierung mit GIF-Streams ==

In dieser Aufgabe implementieren Sie Snake in Haskell.

Das dazu benötigte Rahmenwerk finden Sie auf Übungshomepage.

Die Ausgabe des Spiels soll ein GIF-Stream sein, den man sich im Browser anschauen kann um so das Spiel live mitzuverfolgen.

Es werden 64 Farben unterstützt, die als Int-Tupel von (0,0,0) bis (3,3,3) angesprochen werden.

> type RGB = (Int,Int,Int)

Ein einzelner Frame einer GIF ist definiert als Liste von Zeilen, wobei jede Zeile eine Liste von RGB-Werten ist.

> type Frame = [[RGB]]

Das Rahmenwerk stellt eine Funktion server zur Verfügung:

> server :: PortNumber -> Int -> Logic -> IO ()

Das Rahmenwerk lässt sich mit import GifStream importieren. Es lässt sich wie folgt verwenden:

> main = server 8000 200000 logic

Ziel dieser Aufgabe ist es die Spiellogik von Snake in der Funktion logic zu implementieren.

> logic :: FrameSignal -> IO ()

1) Bilder ausgeben

Um mit dem Rahmenwerk vertraut zu werden sollen in dieser Teilaufgabe abwechselnd zwei Bilder als Frames ausgegeben werden. Generieren Sie die Bilder img und img2, so dass img nur aus schwarzen Pixeln ( (0,0,0) ), img2 nur aus weißen Pixeln ( (3,3,3) ) besteht. Die Höhe und Breite der Bilder soll jeweils 32 Pixel betragen. Für Höhe und Breite von 2 Pixeln sähe die Lösung wie folgt aus:

> img :: Frame
> img = [[(0,0,0),(0,0,0)]
>       ,[(0,0,0),(0,0,0)]]
> img2 :: Frame
> img2 = [[(3,3,3),(3,3,3)]
>        ,[(3,3,3),(3,3,3)]]

Um die Bilder auszugeben erhalten sie in Ihrer logic-Funktion ein FrameSignal, an das Sie mit sendMSignal ein neues Bild senden können.

> sendMSignal :: FrameSignal -> Frame -> IO ()

Um ein Verzögerung zwischen den gesendeten Bildern zu bewirken lässt sich mit threadDelay x ein Warten für x Mikrosekunden auslösen. Importieren Sie hierzu Control.Concurrent

> threadDelay :: Int -> IO ()

Bei IO-intensivem Code, wie er an dieser Stelle vorliegt, bietet es sich an, mit Hilfe der do-Notation Funktionen in imperativem Stil zu schreiben. Um ein einzelnes Bild wiederholt auszugeben könnte man schreiben:

> logic frameSignal = do
>   let
>     loop = do
>       sendMSignal frameSignal img
>       threadDelay delay
>       loop
>   loop

Kompilieren Sie Ihren Code und führen Sie ihn aus:
  ghc -O3 -threaded Snake.hs
  ./Snake

Nun können Sie in Ihrem Browser den erzeugten GIF-Stream unter folgender Adresse anschauen:
  http://localhost:8000

Anderen Teilnehmern Ihres Netzwerks ist es ebenfalls möglich Ihren GIF-Stream zu betrachten, indem Sie statt localhost Ihre IP-Adresse eintragen.

Desweiteren ist es möglich den GIF-Stream aufzunehmen um ihn später anzuschauen:
  wget -O game.gif http://localhost:8000

2) Input
Schreiben Sie eine Funktion, die Benutzereingaben von der Kommandozeile entgegennimmt und daraufhin das Ausgabebild beeinflusst. Es sollen vier Aktionen möglich sein, MoveU, MoveL, MoveD, MoveD, die durch die Tasten wasd ausgelöst werden.

> getChar :: IO Char

In do-Notation lässt sich durch c <- getChar ein Zeichen in die Variable c lesen.

Im Modul Control.Concurrent ist die Funktion forkIO definiert, mit der sich ein neuer Thread starten lässt.

> forkIO :: IO () -> IO ThreadNumber

Rufen Sie forkIO input vor loop auf um einen Eingabethread im Hintergrund laufen zu haben.

Importieren Sie Data.IORef um eine Informationsübertragung zwischen den zwei laufenden Threads zu implementieren. Mit

> actionRef <- newIORef MoveR

erzeugt man einen Informationskanal namens actionRef, der mit dem Wert MoveR initialisert ist. Mit

> writeIORef actionRef MoveL

Lässt sich der Wert MoveL in actionRef schreiben. Mit

> action <- readIORef actionRef

Wird eine Variable action angelegt, die den Wert aus actionRef enthält.

Passen Sie abhängig von der gemachten Eingabe actionRef in input an und machen Sie das Verhalten von loop vom aktuellen Wert von actionRef abhängig.

3) Zustand
Verfahren Sie nun auf ähnliche Weise wie in der vorherigen Aufgabe und fügen Sie IORefs hinzu für die durch die Schlange belegten Felder und das Feld an dem sich das Futterstück befindet.

> type Position = (Int,Int)
> type Snake = [Position]
> type Food = Position

Lesen Sie die IORefs in Ihrer loop und schreiben Sie schließlich die neuen Werte zurück.

4) Feldausgabe
Erzeugen Sie aus dem Feld ein Bild und geben Sie dieses aus.

Dazu benötigen Sie womöglich eine Liste von 

> imgPoss :: [[Position]]

5) Scaling
Um ein spielbar großes Bild zu erhalten implementieren Sie eine scale-Funktion und verwenden Sie diese um jeden Pixel im Spielfeld auf eine beliebige Anzahl Pixel zu skalieren.

> scale :: Int -> Frame -> Frame

6) Verhalten Schlange
Implementieren Sie nun die Zustandsveränderung der Schlange.

> moveSnake :: Snake -> Food -> Action -> Snake

7) Verhalten Futter
Implementieren Sie nun die Zustandsveränderung des Futters.

> moveFood :: Snake -> Food -> IO Food

Zufallszahlen zwischen x und y (einschließlich) lassen sich mit

> r <- randomRIO (x,y)

generieren

Kür) Schreiben Sie ein weiteres Spiel mit GIF-Stream-Ausgabe, zum Beispiel Pong oder Tetris.
